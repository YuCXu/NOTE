# 为什么MySql数据库索引选择使用B+树

##### 一、二叉查找树

1、简介：二叉查找树也称为**有序二叉查找树**，具有以下特征：

​	①任意节点左子树不为空，则左子树的值均小于根节点的值； 

​	②任意节点右子树不为空，则右子树的值均大于于根节点的值； 

​	③任意节点的左右子树也分别是二叉查找树； 

​	④没有键值相等的节点。

![1552647097743](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/26.png)

上图为一个普通的二叉查找树，按照**中序遍历**的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。 

对于上述二叉树进行查找，如查键值为5的记录，先找到根，其键值是6，6>5，因此查找6的左子树，找到3；而3<5，因此查找右子树；一共找了3次。如果按照2、3、5、6、7、8的顺序来找同样需求3次。 用同样的方法再查找键值为8的这个记录，用了3次，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1+2+3+4+5+6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3+3+3+2+2+1）/6=2.3次。**二叉查找树**的平均查找速度比顺序查找来得**更快**。 

2、局限性及应用

一个二叉树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有**n个节点的线性链**，如下图：

![1552648044225](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/27.png)

如上图，如果我们的根节点选择是最大的或者最小的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1+2+3+4+5+5）/2=3.16，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的。因此引出了一个新的定义——**平衡二叉树AVL**。

##### 二、平衡二叉树（AVL）

1、简介：AVL树是带有**平衡条件的二叉查找树**，用**平衡因子**差值判断是否平衡并通过**旋转**来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（**所有节点的左右子树高度差不超过1**）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过**旋转**来保持平衡，而旋转是非常耗时的，由此AVL适合用于插入删除次数比较少，但查找多的情况。

![1552650208248](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/28.png)

从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的**平衡因子**差值都不会大于1。 

2、局限性

由于维护这种高度平衡所付出比从中获得的效率收益还大，故实际应用不多，更多的地方是**追求局部而不是非常严格整体平衡的红黑树**。当然，如果应用场景中对插入删除不频繁，只对查找要求比较高，那么AVL还是优于红黑树。

3、应用

Windows NT内核中广泛存在； 

##### 三、红黑树

1、简介：一种二叉查找树，但在每个节点**增加一个从存储位**表示节点的颜色，可以是red或black。通过对**任意一条从根到叶子的路径上各个节点**着色的方式的限制，红黑树确保没有一条路径会比其他路径长出2倍。它是一种弱平衡二叉树（由于弱平衡，可以得知，相同的节点情况下，AVL树的高度**低于**红黑树），相对于要求严格的AVL树来说，它的**旋转次数变少**，所以对于**搜索、插入、删除操作多**的情况下，用**红黑树**。

2、性质

①每个节点非红即黑；

②根节点是黑的；

③每个叶子节点（叶子节点即树尾端NULL指针或者NULL节点）都是黑的；

④如果一个节点是红的，那么它的两儿子都是黑的；

⑤对于任何节点而言，其到叶子点树NULL指针的每条路径都包含相同的黑节点；

⑥每条路径都包含相同的黑节点。

![1552651890865](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/29.png)

3、应用

①广泛用于C++的STL中，Map和Set都是红黑树实现的；

②著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，**左指针**指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 

③IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；  

④Nginx中用红黑树管理timer，因为红黑树是**有序**的，可以很快的得到距离当前最小的定时器；  

⑤Java中TreeMap的实现。

##### 四、B/B-树

1、简介：MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会访问**磁盘**的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是市面上所提到的多少转每分钟，而磁臂移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过**B树**进行优化，提高磁盘读取时定位的效率。 

为什么B类树可以进行优化？

​	可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的节点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。 

总的来说，B/B+树是为了磁盘或者其他存储设备而设计的一种平衡多路查找树（相对于二叉树，B树每个内节点有多个分支），与红黑树相比，在相同的节点的情况下，一颗B/B+树的高度**远远小于**红黑树的高度。B/B+树上操作的时间通常由存储磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决次访问磁盘的次数，关键字总体相同的情况下，B树的高度越小，访问I/O所花的时间越少。

注意：**B-树就是B树，-只是一个符号。**

2、B树的性质

①定义任意**非叶子结点**最多只有M个儿子，且M>2；  

②根结点的儿子数为[2, M]；

③除根结点以外的非叶子结点的儿子数为[M/2, M]；  

④每个结点存放**至少**M/2-1（取上整）和**至多**M-1个关键字；（至少2个关键字）  ；

⑤非叶子结点的关键字个数=指向儿子的指针个数-1；  

⑥非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]； 

⑦非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于（K[i-1]， K[i]）的子树；  

⑧所有叶子结点位于同一层。

![1552654500894](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/30.png)

上面的图中比如35节点，35代表一个key(索引)，而小黑块代表的是这个key所指向的内容在内存中实际的存储位置，是一个指针。 

##### 五、B+树

1、简介：B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存**索引**，不保存实际数据，数据都保存在**叶子节点**中。

举个文件查找的例子：有3个文件夹a、b、c，a包含b，b包含c，一个文件yang.a，a、b、c就是索引（存储在非叶子节点），a、b、c只是要找的yang.c的key，实际的数据yang.c存储在叶子节点上。

所有的非叶子节点都可以看成**索引**部分。

2、性质

①非叶子节点的子树指针与关键字个数相同；

②非叶子节点的子树指针p[i]，指向关键字值属于[k[i],k[i+1]]的子树。（B树是开区间，也就是说**B树不允许关键字重复**，**B+树允许重复**)； 

③为所有**叶子节点增加一个链指针**；  

④所有关键字都在叶子节点出现（稠密索引）。 （且链表中的关键字恰好是**有序**的）； 

⑤ 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）**数据的数据层**；  

⑥更适合于文件系统。

![1552655538216](https://github.com/YuCXu/NOTE/blob/master/2019.3.15%EF%BC%88%E6%A0%91%EF%BC%89/images/31.png)

非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。 

3、应用

B和B+树主要用在文件系统以及数据库做索引，比如Mysql。

##### 六、B/B+树的性能分析

1、**B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对于B树更小，如果把所有同一内部节点的关键字存放在同一盘快中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 

3、由于B+树的数据都存储在叶子结点中，**分支结点均为索引**，方便扫库，只需要**扫一遍叶子结点**即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次**中序遍历**按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 

观点：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要**去遍历叶子节点就可以实现整棵树的遍历**。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 















